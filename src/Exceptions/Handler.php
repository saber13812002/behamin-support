<?phpnamespace Behamin\Support\Exceptions;use Illuminate\Auth\AuthenticationException;use Illuminate\Database\Eloquent\ModelNotFoundException;use Illuminate\Foundation\Exceptions\Handler as ExceptionHandler;use Illuminate\Http\Response;use Illuminate\Support\Facades\Log;use Illuminate\Validation\UnauthorizedException;use Illuminate\Validation\ValidationException;use Symfony\Component\HttpFoundation\Exception\BadRequestException;use Symfony\Component\HttpFoundation\File\Exception\AccessDeniedException;use Symfony\Component\HttpKernel\Exception\AccessDeniedHttpException;use Symfony\Component\HttpKernel\Exception\BadRequestHttpException;use Symfony\Component\HttpKernel\Exception\MethodNotAllowedHttpException;use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;use Symfony\Component\HttpKernel\Exception\TooManyRequestsHttpException;use Symfony\Component\HttpKernel\Exception\UnauthorizedHttpException;use Symfony\Component\Routing\Exception\MethodNotAllowedException;use Symfony\Component\Routing\Exception\RouteNotFoundException;use Throwable;class Handler extends ExceptionHandler{    /**     * A list of the inputs that are never flashed for validation exceptions.     *     * @var array     */    protected $dontFlash = [        'password',        'password_confirmation',    ];    public function report(Throwable $e)    {        $error = "File: {$e->getFile()} \n Line: {$e->getLine()} \n message: {$e->getMessage()} \n code: {$e->getCode()} \n Trace: {$e->getTraceAsString()}";        Log::channel('elasticsearch')->error($error);        parent::report($e);    }    public function render($request, Throwable $e)    {        if (isRestApi() && !isLocalOrTesting()) {            return $this->renderJson($e);        }        return parent::render($request, $e);    }    /**     * @throws ValidationException     */    private function renderJson(Throwable $exception): string    {        if ($exception instanceof ValidationException) {            $validator = $exception->validator;            $response = apiResponse()->errors($validator->errors()->first(), $validator->errors())                ->status(Response::HTTP_UNPROCESSABLE_ENTITY)                ->get();            throw new ValidationException(                $validator,                $response,                $exception->errorBag            );        }        if ($exception instanceof ClientException) {            return $exception->render();        }        switch (get_class($exception)) {            case BadRequestException::class:            case BadRequestHttpException::class:                $code = Response::HTTP_BAD_REQUEST;                break;            case NotFoundHttpException::class:            case ModelNotFoundException::class:            case RouteNotFoundException::class:                $code = Response::HTTP_NOT_FOUND;                break;            case AuthenticationException::class:            case UnauthorizedException::class:            case UnauthorizedHttpException::class:                $code = Response::HTTP_UNAUTHORIZED;                break;            case AccessDeniedException::class:            case AccessDeniedHttpException::class:                $code = Response::HTTP_FORBIDDEN;                break;            case MethodNotAllowedException::class:            case MethodNotAllowedHttpException::class:                $code = Response::HTTP_METHOD_NOT_ALLOWED;                break;            case TooManyRequestsHttpException::class:                $code = Response::HTTP_TOO_MANY_REQUESTS;                break;            default :                $code = Response::HTTP_INTERNAL_SERVER_ERROR;        }        return apiResponse()->errors(__('error.'.$code))->status($code)->get();    }}